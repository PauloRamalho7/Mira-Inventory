unit frmMain;

interface

uses
  System.Classes,
  System.SysUtils,
  System.Variants,

  Vcl.Buttons,
  Vcl.ComCtrls,
  Vcl.Controls,
  Vcl.Dialogs,
  Vcl.Forms,
  Vcl.Graphics,
  Vcl.StdCtrls,

  ShellApi,

  IniFiles,

  Winapi.Messages,
  Winapi.Windows,

  Xml.XMLDoc,
  Xml.XMLIntf,
  Xml.xmldom, Vcl.ExtCtrls;


type
  TfrmPrincipal = class(TForm)
    trVw: TTreeView;
    XMLDocument: TXMLDocument;
    Edit1: TEdit;
    Empresa: TLabel;
    Responsável: TLabel;
    lblSetor: TLabel;
    Label4: TLabel;
    RadioGroup1: TRadioGroup;
    lblData: TLabel;
    Edit2: TEdit;
    Edit3: TEdit;
    Edit4: TEdit;
    procedure FormShow(Sender: TObject);
  private
    { Private declarations }
    I : TiniFile;
    procedure GenereteTree(XMLNode: IXMLNode; TreeNode: TTreeNode);

  public
    { Public declarations }
  end;

var
  frmPrincipal: TfrmPrincipal;

implementation

{$R *.dfm}

function ExecutarEEsperar(NomeArquivo : String) : Boolean;
var Sh: TShellExecuteInfo;
    CodigoSaida: DWORD;
begin
  FillChar(Sh, SizeOf(Sh), 0) ;
  Sh.cbSize := SizeOf(TShellExecuteInfo) ;
  with Sh do
  begin
    fMask := SEE_MASK_NOCLOSEPROCESS;
    Wnd := Application.Handle;
    lpVerb := nil;
    lpFile := PChar(NomeArquivo);
    nShow := SW_SHOWNORMAL;
  end;
  if ShellExecuteEx(@Sh) then
  begin
    repeat
      Application.ProcessMessages;
      GetExitCodeProcess(Sh.hProcess, CodigoSaida) ;
    until not(CodigoSaida = STILL_ACTIVE);
    Result := True;
  end
  else
    Result := False;
  end;

procedure TfrmPrincipal.FormShow(Sender: TObject);

begin
  I:=TIniFile.Create(ExtractFilePath(Application.ExeName)+'Config.ini');
  lblData.Caption := DateToStr(Date);
//  ExecutarEEsperar('glpi-inventory.bat');
  XMLDocument.LoadFromFile ('tempxml.xml'); // pegando o conteúdo da variável Caminho.
  trVw.Items.Clear; //limpa o conteúdo que estiver na TreeView
  XMLDocument.Active:= True; // ativa o XMLDocument
  GenereteTree(XMLDocument.DocumentElement, nil); //Monta a TreeView

end;

procedure TfrmPrincipal.GenereteTree(XMLNode: IXMLNode; TreeNode: TTreeNode);
var
  NodeText : string;
  NewTreeNode: TTreeNode;
  I : Integer;
 begin
  if XMLNode.NodeType <> ntElement then
    Exit;
  NodeText := XMLNode.NodeName;
  if XMLNode.IsTextElement then
    NodeText := NodeText + '=' + XMLNode.NodeValue;
  NewTreeNode := trVw.Items.AddChild(TreeNode, NodeText);
  if XMLNode.HasChildNodes then
    for I := 0 to XMLNode.ChildNodes.Count - 1 do
      GenereteTree(XMLNode.ChildNodes[I], NewTreeNode);
 end;

end.
